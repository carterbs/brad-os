#!/usr/bin/env bash
#
# Pre-commit hook:
#   1. Block direct commits to main (worktree workflow enforced)
#   2. Scan staged changes for secrets using gitleaks
#   3. Targeted validation pipeline for changed files, with conservative fallback
#
set -euo pipefail

PRE_COMMIT_TIMING_FILE="${PRE_COMMIT_TIMING_FILE:-.cache/pre-commit-timings.jsonl}"

HOOK_START_NS=$(date +%s%N)
GITLEAKS_MS=0
VALIDATE_MS=0
VALIDATE_STATUS="not_run"
VALIDATE_MODE="full"
SCOPED_TEST_FILES=()
SCOPED_TEST_PROJECTS=()

run_timed() {
  local label="$1"
  shift

  local start_ns
  local end_ns
  local status=0
  local elapsed_ms

  start_ns=$(date +%s%N)
  if "$@"; then
    status=0
  else
    status=$?
  fi
  end_ns=$(date +%s%N)
  elapsed_ms=$(( (end_ns - start_ns) / 1000000 ))

  case "$label" in
    gitleaks)
      GITLEAKS_MS=$elapsed_ms
      ;;
    validate)
      VALIDATE_MS=$elapsed_ms
      if [ "$status" -eq 0 ]; then
        VALIDATE_STATUS="success"
      else
        VALIDATE_STATUS="fail"
      fi
      ;;
  esac

  return "$status"
}

log_precommit_timing() {
  local exit_code="$1"
  local hook_end_ns
  local hook_ms
  local now
  local safe_branch
  local scoped_file_count
  local scoped_project_count

  hook_end_ns=$(date +%s%N)
  hook_ms=$(( (hook_end_ns - HOOK_START_NS) / 1000000 ))
  now="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  safe_branch="${BRANCH:-unknown}"
  safe_branch="${safe_branch//\"/\\\"}"
  scoped_file_count="${#SCOPED_TEST_FILES[@]}"
  scoped_project_count="${#SCOPED_TEST_PROJECTS[@]}"

  mkdir -p "$(dirname "$PRE_COMMIT_TIMING_FILE")"
  local log_record
  log_record="{\"timestamp\":\"$now\","
  log_record="${log_record}\"branch\":\"$safe_branch\","
  log_record="${log_record}\"mode\":\"$VALIDATE_MODE\","
  log_record="${log_record}\"staged_files\":${#STAGED_FILES[@]},"
  log_record="${log_record}\"exit_code\":$exit_code,"
  log_record="${log_record}\"hook_ms\":$hook_ms,"
  log_record="${log_record}\"gitleaks_ms\":$GITLEAKS_MS,"
  log_record="${log_record}\"validate_ms\":$VALIDATE_MS,"
  log_record="${log_record}\"validate_status\":\"$VALIDATE_STATUS\","
  log_record="${log_record}\"targeted_test_file_count\":$scoped_file_count,"
  log_record="${log_record}\"targeted_test_project_count\":$scoped_project_count"
  log_record="${log_record}}"
  printf '%s\n' "$log_record" >> "$PRE_COMMIT_TIMING_FILE"
}

trap 'log_precommit_timing "$?"' EXIT

has_test_file() {
  local changed_file="$1"
  if [ "${#SCOPED_TEST_FILES[@]}" -gt 0 ]; then
    for target in "${SCOPED_TEST_FILES[@]}"; do
      [ "$target" = "$changed_file" ] && return 0
    done
  fi
  return 1
}

add_test_file() {
  local test_file="$1"
  if ! has_test_file "$test_file"; then
    SCOPED_TEST_FILES+=("$test_file")
  fi
}

has_test_project() {
  local test_project="$1"
  if [ "${#SCOPED_TEST_PROJECTS[@]}" -gt 0 ]; then
    for project in "${SCOPED_TEST_PROJECTS[@]}"; do
      [ "$project" = "$test_project" ] && return 0
    done
  fi
  return 1
}

add_test_project() {
  local test_project="$1"
  if ! has_test_project "$test_project"; then
    SCOPED_TEST_PROJECTS+=("$test_project")
  fi
}

resolve_tests_for_changed_file() {
  local changed_file="$1"

  if [[ "$changed_file" == *.test.ts ]]; then
    add_test_file "$changed_file"
    return 0
  fi

  if [[ "$changed_file" != *.ts ]]; then
    return 1
  fi

  local candidate_test_file="${changed_file%.ts}.test.ts"
  if [ -f "$candidate_test_file" ]; then
    add_test_file "$candidate_test_file"
    return 0
  fi

  return 1
}

STAGED_FILES=()
while IFS= read -r file; do
  STAGED_FILES+=("$file")
done < <(git diff --cached --name-only --diff-filter=ACMRTD)

# --- Worktree gate: reject commits directly on main ---
BRANCH="$(git symbolic-ref --short HEAD 2>/dev/null)"

if [ "$BRANCH" = "main" ] || [ "$BRANCH" = "master" ]; then
  # Allow merge commits (git merge creates MERGE_HEAD)
  if git rev-parse MERGE_HEAD >/dev/null 2>&1; then
    : # merge commit — allow
  elif [ "${ALLOW_MAIN_COMMIT:-}" = "1" ]; then
    : # explicit override — allow
  else
    echo ""
    echo "ERROR: Direct commits to main are not allowed."
    echo ""
    echo "All changes must be made in git worktrees:"
    echo "  git worktree add ../lifting-worktrees/<branch-name> -b <branch-name>"
    echo ""
    echo "See AGENTS.md for the full worktree workflow."
    echo ""
    echo "To override (merge commits, etc): ALLOW_MAIN_COMMIT=1 git commit ..."
    echo ""
    exit 1
  fi
fi

# --- Gitleaks: scan for secrets ---
if ! command -v gitleaks >/dev/null 2>&1; then
  echo "gitleaks not installed. Install with: brew install gitleaks"
  exit 1
fi

if ! run_timed gitleaks gitleaks protect --staged --verbose; then
  echo ""
  echo "ERROR: gitleaks failed. Install with: brew install gitleaks"
  exit 1
fi

if [ "${#STAGED_FILES[@]}" -eq 0 ]; then
  echo "No staged files found; running full validation."
  VALIDATE_MODE="full_no_staged"
  if ! run_timed validate npm run validate; then
    echo ""
    echo "ERROR: Validation failed. Fix failures before committing."
    echo "  Run 'npm run validate' to reproduce."
    exit 1
  fi
  echo ""
  echo "All pre-commit checks passed."
  exit 0
fi

# --- Scoped validation routing ---
UNKNOWN_SCOPE=false

for file in "${STAGED_FILES[@]}"; do
  case "$file" in
    packages/functions/src/*)
      if ! resolve_tests_for_changed_file "$file"; then
        add_test_project "functions"
      fi
      ;;
    scripts/*)
      if ! resolve_tests_for_changed_file "$file"; then
        add_test_project "scripts"
      fi
      ;;
    *)
      UNKNOWN_SCOPE=true
      ;;
  esac
done

if [ "$UNKNOWN_SCOPE" = true ] || ( [ "${#SCOPED_TEST_FILES[@]}" -eq 0 ] && [ "${#SCOPED_TEST_PROJECTS[@]}" -eq 0 ] ); then
  echo "Running full validation (no safe scoped path found)."
  VALIDATE_MODE="full_fallback"

  if ! run_timed validate npm run validate; then
    echo ""
    echo "ERROR: Validation failed. Fix failures before committing."
    echo "  Run 'npm run validate' to reproduce."
    exit 1
  fi
else
  if [ "${#SCOPED_TEST_FILES[@]}" -gt 0 ]; then
    SCOPED_TEST_FILE_LIST="$(printf "%s\n" "${SCOPED_TEST_FILES[@]}")"
  else
    SCOPED_TEST_FILE_LIST=""
  fi
  if [ "${#SCOPED_TEST_PROJECTS[@]}" -gt 0 ]; then
    SCOPED_TEST_PROJECT_LIST="$(printf "%s\n" "${SCOPED_TEST_PROJECTS[@]}")"
  else
    SCOPED_TEST_PROJECT_LIST=""
  fi

  echo ""
  echo "Running targeted quality checks..."
  if [ "${#SCOPED_TEST_FILES[@]}" -gt 0 ]; then
    echo "  Tests: ${SCOPED_TEST_FILES[*]}"
  fi
  if [ "${#SCOPED_TEST_PROJECTS[@]}" -gt 0 ]; then
    echo "  Test projects: ${SCOPED_TEST_PROJECTS[*]}"
  fi

  VALIDATE_MODE="scoped"
  if ! run_timed validate env \
      BRAD_VALIDATE_TEST_FILES="$SCOPED_TEST_FILE_LIST" \
      BRAD_VALIDATE_TEST_PROJECTS="$SCOPED_TEST_PROJECT_LIST" \
      npm run validate; then
    echo ""
    echo "ERROR: Validation failed. Fix failures before committing."
    echo "  Run 'npm run validate' to reproduce."
    exit 1
  fi
fi

echo ""
echo "All pre-commit checks passed."
